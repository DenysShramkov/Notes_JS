'use strict';

const category = 'toys';

console.log('https//www.utl.com/' + category);
/* Так необходимо было делать в старом стандарте до ES6
проблема такого подхода, если необходимо добавлять множество элементов
строка сильно разрастается*/

console.log(`https//www.url.com/${category}/5`);
/* Работает только с косыми ковычками */

console.log('arr' + ' - obj');
console.log('arr' + 5); /* все равно получится строка */

console.log(5 + +'arr'); /* Ничего не получится
+ перед строкой пытается преобразить ее в число (унарный плюс)
, результат ошибка NaN */

console.log(5 + +'5'); /* результат 10, строка с 5 преобразится */

let incr = 10;
	decr = 10;;

incr++; /* инкремент производит увеличение на 1 */
decr--; /* декремент производит уменьшение на 1 */
/* постфиксная форма сначала возвращает старое значение,а потом производит 
операцию 
console.log(incr++) вернет 10, потом произойдет операция*/
++incr;
--decr; /* префиксная форма записи */

console.log(incr);
console.log(decr);

console.log(5%3); /* вернет остаток от деления */

/* = знак присваивания
== сравнение двух элементов */

console.log(5 == 6);

console.log(5*2 == "10"); /* будет true, так как сравнение идёт по содержимому,
а не по типу данных */

console.log(5*2 === "10"); /* строгое равентство */

/* && оператор и
|| оператор или */

const isChecked = true;
let isClosed = true;

console.log(isChecked && isClosed && true); /* оба */

isClosed = false;

console.log(isChecked || isClosed); /* хотябы один */

console.log(isChecked && !isClosed); 
/* ! оператор отрицаниеб меняет на обратное значениие */

console.log(2+3 != 4); /* неравен */ /* !== строгое неравенство */